# 1111

- [1111 Online Map (30 point(s))](https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856)

## Dijkstra

![image.png](https://i.loli.net/2019/09/07/OqUoLMyX9wYt3iS.png)

```c++
#include <iostream>
#include <vector>
using namespace std;
const int MAX_N = 500 + 5;
const int INF = 0x3fffffff;

int N, M;
int dis[MAX_N][MAX_N];
int Time[MAX_N][MAX_N];
int S, D;
int vis[MAX_N], d[MAX_N], w[MAX_N], disPre[MAX_N];
vector<int> disPath;
int t[MAX_N], nodesNum[MAX_N], TimePre[MAX_N];
vector<int> TimePath;

void dijkstraDis(int s) {
	// init
	fill(vis, vis + MAX_N, 0);
	fill(d, d + MAX_N, INF);
	d[s] = 0;
	fill(w, w + MAX_N, INF);
	for (int i = 0; i < MAX_N; i++) {
		disPre[i] = i;
	}

	for (int i = 0; i < N; i++) {
		int u = -1, MIN = INF;
		for (int j = 0; j < N; j++) {
			if (!vis[j] && d[j] < MIN) {
				u = j;
				MIN = d[j];
			}
		}

		if (u == -1) {
			return;
		}
		vis[u] = true;

		for (int v = 0; v < N; v++) {
			if (!vis[v] && dis[u][v] != INF) {
				if (MIN + dis[u][v] < d[v]) {
					d[v] = MIN + dis[u][v];
					w[v] = w[u] + Time[u][v];
					disPre[v] = u;
				}
				else if (MIN + dis[u][v] == d[v] && w[u] + Time[u][v] < w[v]) {
					w[v] = w[u] + Time[u][v];
					disPre[v] = u;
				}
			}
		}
	}
}

void dfsDisPath(int d) {
	disPath.push_back(d);
	if (d == S) {
		return;
	}
	dfsDisPath(disPre[d]);
}

void dijkstraTime(int s) {
	// init
	fill(vis, vis + MAX_N, 0);
	fill(t, t + MAX_N, INF);
	t[s] = 0;
	fill(nodesNum, nodesNum + MAX_N, INF);
	for (int i = 0; i < MAX_N; i++) {
		TimePre[i] = i;
	}
	for (int i = 0; i < N; i++) {
		int u = -1, MIN = INF;
		for (int j = 0; j < N; j++) {
			if (!vis[j] && t[j] < MIN) {
				u = j;
				MIN = t[j];
			}
		}
		if (u == -1) {
			return;
		}
		vis[u] = 1;
		for (int v = 0; v < N; v++) {
			if (!vis[v] && Time[u][v] != INF) {
				if (t[u] + Time[u][v] < t[v]) {
					t[v] = t[u] + Time[u][v];
					nodesNum[v] = nodesNum[u] + 1;
					TimePre[v] = u;
				}
				else if (t[u] + Time[u][v] == t[v] && nodesNum[u] + 1 < nodesNum[v]) {
					nodesNum[v] = nodesNum[u] + 1;
					TimePre[v] = u;
				}
			}
		}
	}
}

void dfsTimePath(int d) {
	TimePath.push_back(d);
	if (d == S) {
		return;
	}
	dfsTimePath(TimePre[d]);
}

void show(vector<int> v) {
	for (int i = v.size() - 1; i >= 0; i--) {
		cout << v[i];
		if (i > 0) {
			cout << " -> ";
		}
	}
	cout << endl;
}

int main() {
	fill(dis[0], dis[0] + MAX_N * MAX_N, INF);
	fill(Time[0], Time[0] + MAX_N * MAX_N, INF);
	cin >> N >> M;
	for (int m = 0; m < M; m++) {
		int v1, v2, one_way, len, tm;
		cin >> v1 >> v2 >> one_way >> len >> tm;
		dis[v1][v2] = len;
		Time[v1][v2] = tm;
		if (!one_way) {
			dis[v2][v1] = len;
			Time[v2][v1] = tm;
		}
	}
	cin >> S >> D;
	dijkstraDis(S);
	dfsDisPath(D);
	dijkstraTime(S);
	dfsTimePath(D);
	if (disPath == TimePath) {
		printf("Distance = %d; Time = %d: ", d[D], t[D]);
		show(disPath);
	}
	else {
		printf("Distance = %d: ", d[D]);
		show(disPath);
		printf("Time = %d: ", t[D]);
		show(TimePath);
	}
	return 0;
}

/*
Sample Input 1:
10 15
0 1 0 1 1
8 0 0 1 1
4 8 1 1 1
3 4 0 3 2
3 9 1 4 1
0 6 0 1 1
7 5 1 2 1
8 5 1 2 1
2 3 0 2 2
2 1 1 1 1
1 3 0 3 1
1 4 0 1 1
9 7 1 3 1
5 1 0 5 2
6 5 1 1 2
3 5
Sample Output 1:
Distance = 6: 3 -> 4 -> 8 -> 5
Time = 3: 3 -> 1 -> 5
Sample Input 2:
7 9
0 4 1 1 1
1 6 1 1 3
2 6 1 1 1
2 5 1 2 2
3 0 0 1 1
3 1 1 1 3
3 2 1 1 2
4 5 0 2 2
6 5 1 1 2
3 5
Sample Output 2:
Distance = 3; Time = 4: 3 -> 2 -> 5
*/

```

## MLE 的 DFS

![image.png](https://i.loli.net/2019/09/06/zGqjrxihVFJWUMK.png)

```c++
#include <iostream>
#include <map>
#include <vector>
using namespace std;
const int MAX_N = 500;

map<int, int> length;
map<int, int> tm;
vector<int> g[MAX_N];
int s, d;
vector<vector<int>> res;
vector<int> temp;
bool vis[MAX_N] = { false };

void dfs(int root) {
	if (root == d) {
		res.push_back(temp);
		return;
	}
	for (auto it : g[root]) {
		if (!vis[it]) {
			vis[it] = 1;
			temp.push_back(it);
			dfs(it);
			temp.pop_back();
			vis[it] = 0;
		}
	}
}

int getLen(vector<int> v) {
	int s = v[0], len = 0;
	for (int i = 1; i < v.size(); i++) {
		len += length[s * 1000 + v[i]];
		s = v[i];
	}
	return len;
}

int getTime(vector<int> v) {
	int s = v[0], t = 0;
	for (int i = 1; i < v.size(); i++) {
		t += tm[s * 1000 + v[i]];
		s = v[i];
	}
	return t;
}

vector<vector<int>> findShortest(vector<vector<int>> vec) {
	vector<vector<int>> res;
	int MIN = 0x3fffffff;
	for (auto v : vec) {
		if (getLen(v) < MIN) {
			MIN = getLen(v);
			vector<vector<int>>().swap(res);
			res.push_back(v);
		}
		else if (getLen(v) == MIN) {
			res.push_back(v);
		}
	}
	return res;
}

vector<vector<int>> findFastest(vector<vector<int>> vec) {
	vector<vector<int>> res;
	int MIN = 0x3fffffff;
	for (auto v : vec) {
		if (getTime(v) < MIN) {
			MIN = getTime(v);
			vector<vector<int>>().swap(res);
			res.push_back(v);
		}
		else if (getTime(v) == MIN) {
			res.push_back(v);
		}
	}
	return res;
}

vector<vector<int>> findFewestInter(vector<vector<int>> vec) {
	vector<vector<int>> res;
	int MIN = 0x3fffffff;
	for (auto v : vec) {
		if (v.size() < MIN) {
			MIN = v.size();
			vector<vector<int>>().swap(res);
			res.push_back(v);
		}
		else if (v.size() == MIN) {
			res.push_back(v);
		}
	}
	return res;
}

void show(vector<int> v) {
	for (int i = 0; i < v.size(); i++) {
		cout << v[i];
		if (i < v.size() - 1) {
			cout << " -> ";
		}
	}
	cout << endl;
}

int main() {
	int N, M;
	cin >> N >> M;
	for (int m = 0; m < M; m++) {
		int v1, v2, one_way, l, t;
		cin >> v1 >> v2 >> one_way >> l >> t;
		g[v1].push_back(v2);
		length[v1 * 1000 + v2] = l;
		tm[v1 * 1000 + v2] = t;
		if (!one_way) {
			g[v2].push_back(v1);
			length[v2 * 1000 + v1] = l;
			tm[v2 * 1000 + v1] = t;
		}
	}
	cin >> s >> d;
	temp.push_back(s);
	vis[s] = 1;
	dfs(s);
	vector<int>().swap(temp);
	/*
	for (auto v : res) {
		for (auto it : v) {
			cout << it << " ";
		}
		cout << endl;
	}
	// */
	vector<vector<int>> shortest = findShortest(res);
	vector<vector<int>> fastest = findFastest(res);
	if (shortest.size() > 1) {
		res = findFastest(shortest);
		swap(res, shortest);
		vector<vector<int>>().swap(res);
	}
	if (fastest.size() > 1) {
		res = findFewestInter(fastest);
		swap(res, fastest);
		vector<vector<int>>().swap(res);
	}
	if (shortest[0] == fastest[0]) {
		printf("Distance = %d; Time = %d: ", getLen(shortest[0]), getTime(shortest[0]));
		show(shortest[0]);
	}
	else {
		printf("Distance = %d: ", getLen(shortest[0]));
		show(shortest[0]);
		printf("Time = %d: ", getTime(fastest[0]));
		show(fastest[0]);
	}
	return 0;
}

/*
Sample Input 1:
10 15
0 1 0 1 1
8 0 0 1 1
4 8 1 1 1
3 4 0 3 2
3 9 1 4 1
0 6 0 1 1
7 5 1 2 1
8 5 1 2 1
2 3 0 2 2
2 1 1 1 1
1 3 0 3 1
1 4 0 1 1
9 7 1 3 1
5 1 0 5 2
6 5 1 1 2
3 5
Sample Output 1:
Distance = 6: 3 -> 4 -> 8 -> 5
Time = 3: 3 -> 1 -> 5
Sample Input 2:
7 9
0 4 1 1 1
1 6 1 1 3
2 6 1 1 1
2 5 1 2 2
3 0 0 1 1
3 1 1 1 3
3 2 1 1 2
4 5 0 2 2
6 5 1 1 2
3 5
Sample Output 2:
Distance = 3; Time = 4: 3 -> 2 -> 5
*/

```

## References

- [1111. Online Map (30)-PAT甲级真题（Dijkstra + DFS）](https://blog.csdn.net/liuchuo/article/details/52487847)


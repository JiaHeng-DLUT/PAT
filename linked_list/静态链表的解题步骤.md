## 静态链表的解题步骤

1. 定义静态链表

   ```c++
   struct Node {
      int add; // 结点地址
      int val; // 数据域
      int next;   // 指针域
      int flag;   // 结点是否在链表上
      Node() {}
      Node(int _add, int _val, int _next): add(_add), val(_val), next(_next) {}
   } nodes[MAX_N];
   ```

2. 题目一般都会给出一条链表的首结点的地址，那么我们就可以依据这个地址来遍历得到整条链表。需要注意的是，这一步同时也是我们对结点的性质 XXX 进行标记、并且对有效结点的个数进行计数的时候，例如对结点是否在链表上这个性质来说，当我们遍历链表时，就可以把 XXX 置为 `1`（即 `true`）。

   ```c++
   int cnt = 0;
   for (int p = s; p != -1; p = nodes[p].next) {
      nodes[p].flag = 1;
      cnt++;
   }
   ```

4. 很多时候题目给出的结点并不都是有效结点（即可能存在不在链表上的结点）。为了能够可控地访问有效结点，一般都需要用对数组进行排序以把有效结点移到数组左端，这样就可以用步骤 3 得到的 `cnt` 来访问它们。既然需要把有效结点移到前面，那么就可以用之前定义的 XXX 来帮忙。在步骤 2，XXX 需要被初始化为比正常结点的 XXX  取值要小的数值，这个做法就可以在这一步起到作用。由于无效结点的 XXX 在步骤 3 中不会被修改，因此一定比有效结点的 XXX 小。于是在写 `sort` 的排序函数 `cmp` 时，就可以在 `cmp` 的两个参数结点中有无效结点时按 XXX 从大到小排序，这样就可以把有效结点全部移到数组左端。
   一般来说，题目一定会有额外的要求，因此 `cmp` 函数中一般都需要有第二级排序，不过这需要以不同的题目要求来确定。例如，如果题目的要求需要把链表按结点顺序排序，就需要在 `cmp` 函数中建立第二级排序，即在 `cmp` 的两个参数结点中有无效结点时按 XXX 从大到小排序，而当两个参数结点都是有效结点时按结点在链表中的位置从小到大排序（结点的顺序可以在第三步得到）。
   
   ```c++
   bool cmp(Node a, Node b) {
      if (a.XXX == -1 || b.XXX == -1) {
         return a.XXX > b.XXX;
      }
      // 第二级排序
   }
   ```
   

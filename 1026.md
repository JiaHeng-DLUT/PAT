# 1026

- [1026 Table Tennis (30 point(s))](https://pintia.cn/problem-sets/994805342720868352/problems/994805472333250560)

![Accepted]()

```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <functional>		// bit_xor
#include <map>
#include <numeric>			// accumulate
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;

int N;
const int MAX_N = 1e5 + 5;
struct Customer {
	char arrivingTime[10], servingTime[10];
	int arrivingTimeStamp, servingTimeStamp;
	int playingTime, waitingTime;
	bool isVIP = false;
	bool isServed = false;
} customers[MAX_N];

int K;
const int MAX_K = 100 + 5;
struct Table {
	int num = 0;
	int nextServingTimeStamp = 8 * 3600;
	bool isVIP = false;
} tables[MAX_K];
int M;

bool cmp1(Customer c1, Customer c2) {
	return c1.arrivingTimeStamp < c2.arrivingTimeStamp;
}

bool cmp2(Customer c1, Customer c2) {
	return c1.servingTimeStamp < c2.servingTimeStamp;
}

int main() {
	// input
	cin >> N;
	for (int n = 0; n < N; n++) {
		cin >> customers[n].arrivingTime;
		int hh, mm, ss;
		sscanf(customers[n].arrivingTime, "%d:%d:%d", &hh, &mm, &ss);
		// cout << hh << ":" << mm << ":" << ss << endl;
		customers[n].arrivingTimeStamp = hh * 3600 + mm * 60 + ss;
		// cout << customers[n].arrivingTimeStamp << endl;
		cin >> customers[n].playingTime;
		customers[n].playingTime *= 60;
		cin >> customers[n].isVIP;
	}
	cin >> K >> M;
	for (int m = 0; m < M; m++) {
		int t;
		cin >> t;
		tables[t].isVIP = true;
	}
	/*
	for (int n = 0; n < N; n++) {
		cout << customers[n].arrivingTime << " " << customers[n].playingTime << " " << customers[n].isVIP << endl;
	}
	cout << endl;
	// */
	sort(customers, customers + N, cmp1);
	/*
	for (int n = 0; n < N; n++) {
		cout << customers[n].arrivingTime << " " << customers[n].playingTime << " " << customers[n].isVIP << endl;
	}
	cout << endl;
	// */
	// solve 
	int t = 1, i = 0, c;
	queue<int> VIP;
	queue<int> nonVIP;
	while (1) {
		if (tables[t].nextServingTimeStamp >= 21 * 3600) {
			break;
		}
		// update VIP and nonVIP 
		for (; i < N; i++) {
			if (customers[i].arrivingTimeStamp < tables[t].nextServingTimeStamp) {
				if (customers[i].isVIP) {
					VIP.push(i);
				}
				else {
					nonVIP.push(i);
				}
			}
			else {
				break;
			}
		}

		if (VIP.empty() && nonVIP.empty()) {	// 没有人在排队
			if (i >= N) {						// 没人了
				break;
			}
			else {								// 还有人
				c = i;
				i++;
			}
		}
		else {									// 有人在排队
			if (!VIP.empty()) {					// 有 VIP 在排队 
				c = VIP.front();
				if (!tables[t].isVIP && !nonVIP.empty() && customers[nonVIP.front()].arrivingTimeStamp < customers[VIP.front()].arrivingTimeStamp) {	// 空闲桌不是 VIP 桌，并且有 nonVIP 在 VIP 前面
					c = nonVIP.front();
					nonVIP.pop();
				}
				else {
					VIP.pop();
				}
			}
			else {								// 没有 VIP 在排队
				c = nonVIP.front();
				nonVIP.pop();
			}
		}
		// cout << t << " " << c << endl;

		// customer
		customers[c].servingTimeStamp = max(tables[t].nextServingTimeStamp, customers[c].arrivingTimeStamp);
		sprintf(customers[c].servingTime, "%02d:%02d:%02d", (customers[c].servingTimeStamp / 3600), (customers[c].servingTimeStamp % 3600 / 60), (customers[c].servingTimeStamp % 3600 % 60));
		customers[c].waitingTime = ceil(((double)customers[c].servingTimeStamp - (double)customers[c].arrivingTimeStamp) / 60);
		customers[c].isServed = true;

		// table
		tables[t].num++;
		tables[t].nextServingTimeStamp = customers[c].servingTimeStamp + customers[c].playingTime;

		// update t 
		int minNextServingTimeStamp = 21 * 3600;
		for (int k = 1; k <= K; k++) {
			if (tables[k].nextServingTimeStamp < minNextServingTimeStamp) {
				t = k;
				minNextServingTimeStamp = tables[k].nextServingTimeStamp;
			}
		}
	}
	sort(customers, customers + N, cmp2);
	// output
	for (int n = 0; n < N; n++) {
		if (customers[n].isServed) {
			cout << customers[n].arrivingTime << " " << customers[n].servingTime << " " << customers[n].waitingTime << endl;
		}
	}
	for (int k = 1; k <= K; k++) {
		cout << tables[k].num;
		if (k < K) {
			cout << " ";
		}
	}
	cout << endl;
	// output
	return 0;
}

/*
Sample Input:
9
20:52:00 10 0
08:00:00 20 0
08:02:00 30 0
20:51:00 10 0
08:10:00 5 0
08:12:00 10 1
20:50:00 10 0
08:01:30 15 1
20:53:00 10 1
3 1
2
Sample Output:
08:00:00 08:00:00 0
08:01:30 08:01:30 0
08:02:00 08:02:00 0
08:12:00 08:16:30 5
08:10:00 08:20:00 10
20:50:00 20:50:00 0
20:51:00 20:51:00 0
20:52:00 20:52:00 0
3 3 2
*/

```

## References



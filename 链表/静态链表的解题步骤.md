## 静态链表的解题步骤

1. 定义静态链表

   ```c++
   struct Node {
   	int address;	// 结点地址
   	typename data;	// 数据域
   	int next;	// 指针域
   	XXX;	// 结点的某个性质，不同的题目会有不同的设置
   }nodes[MAX_N];
   ```

2. 在程序的开始，对静态链表进行**初始化**。一般来说，需要对定义中的 XXX 进行初始化，将其定义为正常情况下达不到的数字（一般来说需要小于所有能达到的数字，理由在第四步说明），例如对结点是否在链表上这个性质来说，我们可以初始化为 `0`（即 `false`），表示结点不在链表上。

   ```c++
   for (int i = 0; i < MAX_N; i++) {
   	nodes[i].XXX = 0;
   }
   ```

3. 题目一般都会给出一条链表的首结点的地址，那么我们就可以依据这个地址来遍历得到整条链表。需要注意的是，这一步同时也是我们对结点的性质 XXX 进行标记、并且对有效结点的个数进行计数的时候，例如对结点是否在链表上这个性质来说，当我们遍历链表时，就可以把 XXX 置为 `1`（即 `true`）。

   ```c++
   int p = begin, cnt = 0;
   while (p != -1) {
   	XXX = 1;
   	cnt++;
   	p = nodes[p]->next;
   }
   ```

4. 由于使用静态链表时，是直接采用地址映射（hash）的方式，这就会使得数组下标的不连续，而很多时候题目给出的结点并不都是有效结点（即可能存在不在链表上的结点）。为了能够可控地访问有效结点，一般都需要用对数组进行排序以把有效结点移到数组左端，这样就可以用步骤 3 得到的 `cnt` 来访问它们。
   既然需要把有效结点移到前面，那么就可以用之前定义的 XXX 来帮忙。在步骤2，XXX 需要被初始化为比正常结点的 XXX  取值要小的数值，这个做法就可以在这一步起到作用。由于无效结点的 XXX 在步骤 3 中不会被修改，因此一定比有效结点的 XXX 小。于是在写 `sort` 的排序函数 `cmp` 时，就可以在 `cmp` 的两个参数结点中有无效结点时按 XXX 从大到小排序，这样就可以把有效结点全部移到数组左端。
   一般来说，题目一定会有额外的要求，因此 `cmp` 函数中一般都需要有第二级排序，不过这需要以不同的题目要求来确定。例如，如果题目的要求需要把链表按结点顺序排序，就需要在 `cmp` 函数中建立第二级排序，即在 `cmp` 的两个参数结点中有无效结点时按 XXX 从大到小排序，而当两个参数结点都是有效结点时按结点在链表中的位置从小到大排序（结点的顺序可以在第三步得到）。

   ```c++
   bool cmp(Node a, Node b) {
   	if (a.XXX == -1 || b.XXX == -1) {
   		return a.XXX > b.XXX;
   	}
   	else {
   		// 第二级排序
   	}
   }
   ```
   
5. 在经历了步骤 4 后，链表中的有效结点就都在数组左端了，且已经按结点的性质进行了排序，接下来就要看题目在排序之后具体要求做什么了（比较常见的是按各种不同的要求输出链表）。
